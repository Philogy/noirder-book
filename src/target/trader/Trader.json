{
  "name": "Trader",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 1,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "token0",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "token1",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+3d93MTRxQH8JVlSTghBNJs02ICMc3AnXSyTrQ4kF4I6SEVK5YSUjAhTnEqIb2TnkAKIb3Qe2//F8P7zuwNh2z4RU8edr7czJszlme5z91pr+57x40xm8ypKWHnXXbu1Tb5KWkjNUi7Oa8zCMqFbNnP+d1etlgK816QL3WGfujnw3xPNszlymEQFoqlYsEr+kGu7FfyxVzFNpzSW0avHu60tJGugzt9jrsz0kamDu6MsvtM+3uty9mquJwJuy7bbHvNEickWuy8lWzeITHabjOsl5F2vYw+B5ZrjDl90t6vxhq972i0/qJlHGsd6FvG2d/H+65ov8M0XuLK2DZoqGpjfOxv2ySSNs40dSmaEubs28CrbfKbzdD0QV5tk99mdPugaJogMdz+3CTRaH9uiP0uWWVqin0eTWmjv/0HO9Z6NU44xxgWc5gq7wj7+Sj77+W9fcsq/QtXlrv7yj2LevvK8ZWXsvPkIA0lBllxmBpj/3m6qp34io0+y5iBXwK1NRxvU3uPnWDcOLpfpbec2epeGG1HvfBEM7AXjo76mCZJXG0G9sJRG5Nif9tuhqwXzg5FL9xi3OiF2019euHJ5nwvHPee74W12p5s3OiFp+gsZyXIBqctZ4Py+kwomqfWadtomxsUzdMcMScVzdMdMTcqmjscMacUzTMcMacVzTMdMWcUzbMcMY9RNHuOmFsVzT6hOUtozhGaA0JzntDcSWguEJpDQnOR0Dyb0DyH0DyX0DyP0Dyf0HwNobmL0HwtoXkBoXkhofk6QvP1hOYbCM03EppvIjTfTGi+hdB8K6H5NkLz7YTmRYTmOwjNiwnNdxKa7yI0301ovofQfC+h+T5C8/2E5gcIzUsIzQ8Smh8iND9MaH6E0PwoofkxQvNSQnM3oblEaH6c0NxDaC4TmiuE5icIzU8SmpcRmp8iND9NaH6G0PwsoXk5obmX0LyC0PwcoXklofl5QnOfI+Y2RfMLjpjbFc0vOmLW3LdfIjS/TGjuJzS/Qmh+ldD8GqH5dULzG4TmNwnNqwjNbxGaVxOa3yY0v+OIeZyi+V1HzBMVze85Ytbct98nNH9AaP6Q0PwRofljQvMnhOZPCc2fEZo/JzSvITR/QWj+ktD8FaH5a0fMUxTN3xCav3XErLlvf0do/p7Q/AOheS2heR2h+UdC80+E5p8Jzb8QmtcTmn8lNG8gNP9GaP6d0PwHoflPQvNfhOa/Cc3/EJr/JTT/R2j+n9C8kdC8idC8mdC8hdC8ldC8jdC8ndC8wxHzMEXzTkfMTYrmXY6YL1A073bEfKGieY8j5uGK5r2OmC9SNO9zxDxC0bzfEfPFiuYDjphHKpoPOmIepWg+5Ij5EkXzYUfMlyqajzhivkzRfNQR8+WK5mOOmK9QNB9XNLfYdhLWnJRolEhJpCUyErgmxDUSrhlwDo1zSpxj4ZwDx2Ack9BHo8/Cdxj7NLYxzM0SLbH1us7Op0pMk5gu0SExQ2KmxCyYJHyJLNaVRCCRl+iUKEiEEkWJ2RJzJOZKzJOYLxHVukct9AUSqJWN2tGopYzawqi1i9qzqMWK2qSo1YnalajliNqGqPW3WAK14FAbDbXCUDsLtaRQWwm1hlB7Z4kEarOgVglqd6CWBWo7oNbBUgnkwi9JIFc6cocjlzZySyPXMnIPIxcvctMiVytylyKXJ3JbItfjCgnkAkRuPOSKQ+405BJDbi3kmkLupX4J5OZBrhrkbkEuE+T2QK6LVRLIhbBaAmPlMXYcY6kxthhjbTH2FGMxMTYRY/Uwdg1juTC2CWN91khgLAjGRmCsAN6dx7vkeLca7xrj3Vu8i7rWbk+8u4d32fBuF951Wi+Bd2E2SOBdCbw7gGfpeLaMZ6149ohncXg2hWc1eHaBe/m4t417vbj3iXuBuDeGe0W4d4J7Cbi2xrUmrr1wLYJzc5yr4twN5zI4tuNYd0QCfSH6BnxXoukkFWpBy6inAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "trade_token0",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "token0_from",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "amount_token0",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "amount_token1",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce_transfer_token0",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce_transfer_token1",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "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8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM8xqM85qM85qM85qM85qM85o3pWMn47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wm47wW47wW47wW47wW47zWTenYxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivxTivYpxXMc6rGOdVjPOqm9KxxTivYpxXMc6rGOdVjPMqxnkV47yKcV7FOK9inFcxzqsY51WM8yrGeRXjvIpxXsU4r2KcVzHOqxjnVYzzKsZ5FeO8inFexTivYpxXMc6rGOdVjPMqxnkV47yKcV7FOK9inFcxzqsY51WM8yrGeRXjvIpxXsU4r2KcVzHOqxjnVYzzKsZ5FeO8inFexTivYpxXMc6rGOdVjPMqxnkV47yKcV7FOK9inFcxzqsY51WM8yrGeRXjvIpxXsU4r2KcVzHOqxjnVYzzKsZ5FeO8inFexTivYpxXMc6rGOdVjPMqxnkV47yKcV7FOK9inFcxzqsY51WM8yrGeRXjvIpxXsU4r2KcVzHOqxjnVYzzKsZ5FeO8DsZ5HYzzOhjndTDO67gpHXswzutgnNfBOK+DcV4H47wOxnkdjPM6GOd1MM7rYJzXwTivg3FeB+O8DsZ5HYzzOhjndTDO62Cc18E4r4NxXgfjvA7GeR2M8zoY53UwzutgnNfBOK+DcV4H47wOxnkde87r/iNfk0Tre0m2OvbUJFsde2qSrY49NclWx56ZZM95nZpkq2NPTbLVsacm2erYU5NsdeypSZiO3XNepyZhOnbPeZ2ahOnYPed1ahKmY/ec16lJmI7dc16nJmE6ds95nZqE6dg953VqEqZj95zXqUmYjt1zXqcmYTp2z3mdmoTp2D3ndWoSpmP3nNepSZiO3XNepyZhOnbPeZ2ahOnYPed1ahKmY/ec16lJmI7dc16nJmE6ds95nZqE6dg953VqEqZj95zXqUmYjt1zXqcmYTp2z3mdmoTp2D3ndWoSpmP3nNepSZiO3XNepyZhOnbPeZ2ahOnYPed1ahKlY9ttD3qdG0Vp2XsUpWbvUZSevUdRivYeRWnaexSlau9RlK69R1HK9h7Fads98nVuFKdt99DXuVGctt1jX+dGcdp2D36dG8Vp2z36dW4Up2338Ne5UZy23eNf50Zx2nYPgJ0bxWnbPQJ2bhSnbfcQ2LlRnLbdY2DnRnHadg+CnRvFads9CnZuFKdtGQx2j+K0LcPB7lGctmVA2D2K07YMCbtHcdqWQWH3KE7bMizsHsVpWwaG3aM4bcvQsHsUp20ZHHaP4rQtw8PuUZy2ZYDYPYrTtgwRu0dx2pZBYvcoTtsyTOwexWlbBordozhty1CxexSnbRksdo/itC3Dxe5RnLZlwNg9itO2DBm7R3HalkFj9yhO2zJs7B7FaVsGjt2jOG3L0LF7FKdtGTx2j+K0LcPH7lGctmUA2T2K07YMIbtHcdqWQWT3KE7bMozsHsVpWwaS3aM4bctQsnsUpm2bY8maY8maY8maY8najWnb5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liy5liycCxZOJYsHEsWjiWLG9O24ViycCxZOJYsHEsWjiULx5KFY8nCsWThWLJwLFk4liwcSxaOJQvHkoVjycKxZOFYsnAsWTiWLBxLFo4lC8eShWPJwrFk4ViycCxZOJYsHEsWjiULx5KFY8nCsWThWLJwLFk4liwcSxaOJQvHkoVjycKxZOFYsnAsWTiWLBxLFo4lC8eShWPJwrFk4ViycCxZOJYsHEsWjiULx5KFY8nCsWThWLJwLFk4liwcSxaOJQvHkoVjycKxZOFYsnAsWTiWLBxLFo4lC8eShWPJwrFk4ViycCxZOJYsHEsWjiULx5KFY8nCsWThWLJwLFk4liwcSxaOJQvHkoVjycKxZOFYsnAsWTiWLBxLFo4lC8eShWPJ0rFk6ViydCxZOpYsb0zbpmPJ0rFk6ViydCxZOpYsHUuWjiVLx5KlY8nSsWTpWLJ0LFk6liwdS5aOJUvHkqVjydKxZOlYsnQsWTqWLB1Llo4lS8eSpWPJ0rFk6ViydCxZOpYsHUuWjiVLx5KlY8nSsWTpWLJ0LFk6liwdS5aOJUvHkqVjydKxZOlYsnQsWTqWLB1Llo4lS8eSpWPJ0rFk6ViydCxZOpYsHUuWjiVLx5KlY8nSsWTpWLJ0LFk6liwdS5aOJUvHkqVjydKxZOlYsnQsWTqWLB1Llo4lS8eSpWPJ0rFk6ViydCxZOpYsHUuWjiVLx5KlY8nSsWTpWLJ0LFk6liwdS5aOJUvHkqVjydKxZOlYsnQsWTqWLB1Llo4l644l644l644l644l6zembbtjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjybpjyYZjyYZjyYZjyYZjycaNadvhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLhWLLpWLLpWLLpWLLpWLJ5Y9p2OpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOpZsOZZsOZZsOZZsOZZs3Zi2XY4lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44lW44l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"
    ],
    "fileMap": {
      "1": {
        "source": "mod interfaces;\nmod address_note;\n\ncontract Trader {\n\n    use dep::std::option::Option;\n\n    use dep::aztec::{\n        state_vars::immutable_singleton::ImmutableSingleton,\n        context::{PrivateContext, PublicContext, Context},\n        types::address::AztecAddress,\n        note::{\n            utils as note_utils,\n            note_header::NoteHeader\n        }\n    };\n\n    use dep::authwit::auth::assert_current_call_valid_authwit;\n\n    use dep::aztec::oracle::debug_log::{\n        debug_log_field,\n        debug_log_array_with_prefix\n    };\n\n    use crate::{\n        address_note::{AddressNote, ADDRESS_NOTE_LEN, AddressNoteMethods},\n        interfaces::Token\n    };\n\n    struct Storage {\n        token0: ImmutableSingleton<AddressNote, 1>,\n        token1: ImmutableSingleton<AddressNote, 1>\n    }\n\n    impl Storage {\n        fn init(context: Context) -> pub Self {\n            Storage {\n                token0: ImmutableSingleton::new(context, 1, AddressNoteMethods),\n                token1: ImmutableSingleton::new(context, 2, AddressNoteMethods)\n            }\n        }\n    }\n\n\n    #[aztec(private)]\n    fn constructor(token0: Field, token1: Field) {\n        storage.token0.initialize(&mut AddressNote::new(token0), Option::none(), true);\n        storage.token1.initialize(&mut AddressNote::new(token1), Option::none(), true);\n    }\n\n    #[aztec(private)]\n    fn trade_token0(\n        token0_from: AztecAddress,\n        amount_token0: Field,\n        amount_token1: Field,\n        nonce: Field,\n        nonce_transfer_token0: Field,\n        nonce_transfer_token1: Field\n    ) {\n        let token0_addr = storage.token0.get_note().address;\n        let token1_addr = storage.token1.get_note().address;\n\n        assert_current_call_valid_authwit(&mut context, token0_from);\n\n\n        Token::at(token0_addr).transfer(\n            &mut context,\n            token0_from.address,\n            context.msg_sender(),\n            amount_token0,\n            nonce_transfer_token0\n        );\n        Token::at(token1_addr).transfer(\n            &mut context,\n            context.msg_sender(),\n            token0_from.address,\n            amount_token1,\n            nonce_transfer_token1\n        );\n    }\n\n\n    unconstrained fn compute_note_hash_and_nullifier(\n        contract_address: Field,\n        nonce: Field,\n        storage_slot: Field,\n        preimage: [Field; ADDRESS_NOTE_LEN],\n    ) -> [Field; 4] {\n        let note_header = NoteHeader { contract_address, nonce, storage_slot, is_transient: false };\n        note_utils::compute_note_hash_and_nullifier(AddressNoteMethods, note_header, preimage)\n    }\n}\n",
        "path": "/home/philippe/Documents/Programming/Aztec/noirder-book/contracts/trader/src/main.nr"
      },
      "6": {
        "source": "mod poseidon;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input : [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input : [u8; N]) -> [u8; 32] {}\n\npub fn pedersen<N>(input : [Field; N]) -> [Field; 2] {\n    pedersen_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\npub fn pedersen_with_separator<N>(_input : [Field; N], _separator : u32) -> [Field; 2] {}\n\npub fn pedersen_hash<N>(input : [Field; N]) -> Field {\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(_input : [Field; N], _separator : u32) -> Field {}\n\n#[foreign(hash_to_field_128_security)]\npub fn hash_to_field<N>(_input : [Field; N]) -> Field {}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input : [u8; N], _message_size: u32) -> [u8; 32] {}\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\nfn mimc<N>(x: Field, k: Field, constants: [Field; N], exp : Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1 .. constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    };\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS = 91;\n\n//mimc implementation with hardcoded parameters for BN254 curve.\npub fn mimc_bn254<N>(array: [Field; N]) -> Field {\n    //mimc parameters\n    let exponent = 7;\n    //generated from seed \"mimc\" using keccak256 \n    let constants: [Field; MIMC_BN254_ROUNDS] = [\n        0, \n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533,\n    ];\n\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, constants, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n",
        "path": "std/hash.nr"
      },
      "34": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option.nr"
      },
      "37": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:historic-block-data\nstruct HistoricBlockData {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:historic-block-data\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/abi.nr"
      },
      "40": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, self.this_address(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    blocks_tree_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/context.nr"
      },
      "41": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse crate::constants_gen::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n  let sha256_hashed = sha256(bytes_to_hash);\n\n  // Convert it to a field element\n  let mut v = 1;\n  let mut high = 0 as Field;\n  let mut low = 0 as Field;\n\n  for i in 0..16 {\n      high = high + (sha256_hashed[15 - i] as Field) * v;\n      low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n      v = v * 256;\n  }\n\n  // Abuse that a % p + b % p = (a + b) % p and that low < p\n  let hash_in_a_field = low + high * v;\n\n  hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n  // TODO(#1205) This is probably not the right index to use\n  pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n  pedersen_hash_with_separator(inputs, hash_index)\n}",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/hash.nr"
      },
      "47": {
        "source": "use crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n    broadcast: bool,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let preimage = serialize(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        let broadcast = note_interface.broadcast;\n        broadcast(context, storage_slot, *note);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/note/lifecycle.nr"
      },
      "48": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(\n    fields: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    };\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/note/note_getter.nr"
      },
      "50": {
        "source": "use crate::hash::pedersen_hash;\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/note/note_hash.nr"
      },
      "54": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\npub fn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/note/utils.nr"
      },
      "56": {
        "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/oracle/arguments.nr"
      },
      "57": {
        "source": "use crate::constants_gen::CALL_PRIVATE_FUNCTION_RETURN_SIZE;\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: Field,\n    _function_selector: Field,\n    _args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: Field,\n    function_selector: Field,\n    args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {\n    call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n    )\n}",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/oracle/call_private_function.nr"
      },
      "66": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_created_note_oracle(storage_slot, preimage, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(\n    _nullifier: Field,\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S],\n)-> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, return_size, placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let preimage = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(preimage);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    };\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(\n    _inner_nullifier: Field,\n) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/oracle/notes.nr"
      },
      "69": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::hash::pedersen_hash;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    pub fn hash(self) -> Field {\n        pedersen_hash([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/private_call_stack_item.nr"
      },
      "73": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\nuse crate::context::{PrivateContext, Context};\nuse crate::note::{\n    lifecycle::create_note,\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::singleton::compute_singleton_initialization_nullifier;\n\n// docs:start:struct\nstruct ImmutableSingleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<Field>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> ImmutableSingleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        ImmutableSingleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<Field>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(\n        self,\n        note: &mut Note, \n        owner: Option<Field>,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(\n            context,\n            self.storage_slot,\n            note,\n            self.note_interface,\n            broadcast,\n        );\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note(self) -> Note {\n        let context = self.context.unwrap();\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot, self.note_interface)\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/state_vars/immutable_singleton.nr"
      },
      "77": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{EMPTY_NULLIFIED_COMMITMENT, GENERATOR_INDEX__INITIALIZATION_NULLIFIER};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note},\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::{\n    get_secret_key::get_secret_key,\n    notes::check_nullifier_exists,\n};\nuse crate::hash::pedersen_hash;\n\npub fn compute_singleton_initialization_nullifier(storage_slot: Field, owner: Option<Field>) -> Field {\n    if owner.is_some() {\n        let secret = get_secret_key(owner.unwrap_unchecked());\n        pedersen_hash(\n            [storage_slot, secret.low, secret.high],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    } else {\n        pedersen_hash(\n            [storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\n// docs:start:struct\nstruct Singleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<Field>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> Singleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Singleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<Field>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(\n        self,\n        note: &mut Note,\n        owner: Option<Field>,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(\n        self,\n        new_note: &mut Note,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note, self.note_interface);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, self.note_interface, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note(self, broadcast: bool) -> Note {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note, self.note_interface);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, self.note_interface, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/state_vars/singleton.nr"
      },
      "87": {
        "source": "pub fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/aztec/src/utils.nr"
      },
      "90": {
        "source": "use dep::aztec::{\n  context::{PrivateContext, PublicContext, Context},\n  constants_gen::{EMPTY_NULLIFIED_COMMITMENT, GENERATOR_INDEX__SIGNATURE_PAYLOAD},\n  types::address::AztecAddress,\n  abi::hash_args,\n  hash::pedersen_hash,\n};\n\nglobal IS_VALID_SELECTOR = 0xe86ab4ff;\nglobal IS_VALID_PUBLIC_SELECTOR = 0xf3661153;\n\n// @todo #2676 Should use different generator than the payload to limit probability of collisions.\n\n// docs:start:assert_valid_authwit\n// Assert that `on_behalf_of` have authorized `message_hash` with a valid authentication witness\npub fn assert_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, message_hash: Field) {\n  let result = context.call_private_function(on_behalf_of.address, IS_VALID_SELECTOR, [message_hash])[0];\n  context.push_new_nullifier(message_hash, EMPTY_NULLIFIED_COMMITMENT);\n  assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n// docs:end:assert_valid_authwit\n\n// docs:start:assert_current_call_valid_authwit\n// Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n  // message_hash = H(caller, contract_this, selector, args_hash)\n  let message_hash = pedersen_hash(\n    [context.msg_sender(), context.this_address(), context.selector(), context.args_hash],\n    GENERATOR_INDEX__SIGNATURE_PAYLOAD\n  );\n  assert_valid_authwit(context, on_behalf_of, message_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n// docs:start:assert_valid_authwit_public\n// Assert that `on_behalf_of` have authorized `message_hash` in a public context\npub fn assert_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, message_hash: Field) {\n  let result = context.call_public_function(on_behalf_of.address, IS_VALID_PUBLIC_SELECTOR, [message_hash])[0];\n  context.push_new_nullifier(message_hash, EMPTY_NULLIFIED_COMMITMENT);\n  assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n// docs:end:assert_valid_authwit_public\n\n// docs:start:assert_current_call_valid_authwit_public\n// Assert that `on_behalf_of` have authorized the current call in a public context\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress) {\n  // message_hash = H(caller, contract_this, selector, args_hash)\n  let message_hash = pedersen_hash(\n    [context.msg_sender(), context.this_address(), context.selector(), context.args_hash],\n    GENERATOR_INDEX__SIGNATURE_PAYLOAD\n  );\n  assert_valid_authwit_public(context, on_behalf_of, message_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n// docs:start:compute_authwit_message_hash\n// Compute the message hash to be used by an authentication witness \npub fn compute_authwit_message_hash<N>(\n  caller: AztecAddress, \n  target: AztecAddress, \n  selector: Field, \n  args: [Field; N]\n) -> Field {\n  let args_hash = hash_args(args);\n  pedersen_hash([caller.address, target.address, selector, args_hash], GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n}\n// docs:end:compute_authwit_message_hash",
        "path": "/home/philippe/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.13.1/yarn-project/aztec-nr/authwit/src/auth.nr"
      },
      "97": {
        "source": "use dep::aztec::context::{\n    PrivateContext,\n    PublicContext\n};\nuse dep::aztec::selector::compute_selector;\n\nuse dep::aztec::constants_gen::RETURN_VALUES_LENGTH;\n\nstruct Token {\n    address: Field,\n}\n\nimpl Token {\n    pub fn at(address: Field) -> Self {\n        Self { address }\n    }\n\n    pub fn transfer(self: Self, context: &mut PrivateContext, from: Field, to: Field, amount: Field, nonce: Field) -> [Field; RETURN_VALUES_LENGTH] {\n        context.call_private_function(\n            self.address,\n            compute_selector(\"transfer((Field),(Field),Field,Field)\"),\n            [from, to, amount, nonce]\n        )\n    }\n}\n",
        "path": "/home/philippe/Documents/Programming/Aztec/noirder-book/contracts/trader/src/interfaces.nr"
      },
      "98": {
        "source": "use dep::aztec::note::{\n    note_interface::NoteInterface,\n    note_header::NoteHeader,\n    utils::compute_siloed_note_hash\n};\nuse dep::aztec::context::PrivateContext;\nuse dep::aztec::oracle::get_secret_key::get_secret_key;\n\nglobal ADDRESS_NOTE_LEN: Field = 1;\n\n// Stores an address\nstruct AddressNote {\n    address: Field,\n    header: NoteHeader,\n}\n\nimpl AddressNote {\n    pub fn new(address: Field) -> Self {\n        AddressNote {\n            address,\n            header: NoteHeader::empty(),\n        }\n    }\n\n    pub fn serialize(self) -> [Field; ADDRESS_NOTE_LEN] {\n        [self.address]\n    }\n\n    pub fn compute_nullifier(self) -> Field {\n        let siloed_note_hash = compute_siloed_note_hash(AddressNoteMethods, self);\n        dep::std::hash::pedersen([ siloed_note_hash ])[0]\n    }\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n}\n\nfn deserialize(preimage: [Field; ADDRESS_NOTE_LEN]) -> AddressNote {\n    AddressNote {\n        address: preimage[0],\n        header: NoteHeader::empty(),\n    }\n}\n\nfn serialize(note: AddressNote) -> [Field; ADDRESS_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: AddressNote) -> Field {\n    // TODO(#1205) Should use a non-zero generator index.\n    dep::std::hash::pedersen(note.serialize())[0]\n}\n\nfn compute_nullifier(note: AddressNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: AddressNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut AddressNote, header: NoteHeader) {\n    note.set_header(header);\n}\n\n// Empty broadcast to satisfy interface\nfn broadcast(context: &mut PrivateContext, slot: Field, note: AddressNote) { }\n\nglobal AddressNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast\n};\n",
        "path": "/home/philippe/Documents/Programming/Aztec/noirder-book/contracts/trader/src/address_note.nr"
      }
    }
  }
}