{
  "name": "Trader",
  "functions": [
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "token0",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "token1",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "trade_token0",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "token0_from",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "amount_token0",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "amount_token1",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce_transfer_token0",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce_transfer_token1",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "debug": {
    "debugSymbols": [
      "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"
    ],
    "fileMap": {
      "6": {
        "source": "mod poseidon;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input : [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input : [u8; N]) -> [u8; 32] {}\n\npub fn pedersen<N>(input : [Field; N]) -> [Field; 2] {\n    pedersen_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\npub fn pedersen_with_separator<N>(_input : [Field; N], _separator : u32) -> [Field; 2] {}\n\n#[foreign(hash_to_field_128_security)]\npub fn hash_to_field<N>(_input : [Field; N]) -> Field {}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input : [u8; N], _message_size: u32) -> [u8; 32] {}\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\nfn mimc<N>(x: Field, k: Field, constants: [Field; N], exp : Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1 .. constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    };\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS = 91;\n\n//mimc implementation with hardcoded parameters for BN254 curve.\npub fn mimc_bn254<N>(array: [Field; N]) -> Field {\n    //mimc parameters\n    let exponent = 7;\n    //generated from seed \"mimc\" using keccak256 \n    let constants: [Field; MIMC_BN254_ROUNDS] = [\n        0, \n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533,\n    ];\n\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, constants, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n",
        "path": "std/hash"
      },
      "34": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option"
      },
      "37": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\n// docs:start:historic-block-data\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:historic-block-data\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/abi"
      },
      "40": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, self.this_address(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 49),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 65),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 81),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 97),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 101),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 105),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 107),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 109),\n                encrypted_log_preimages_length: fields[111],\n                unencrypted_log_preimages_length: fields[112],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[113],\n                    nullifier_tree_root : fields[114],\n                    contract_tree_root : fields[115],\n                    l1_to_l2_messages_tree_root : fields[116],\n                    blocks_tree_root : fields[117],\n                    public_data_tree_root: fields[118],\n                    global_variables_hash: fields[119],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[120], fields[121]),\n                    constructor_vk_hash : fields[122],\n                    function_tree_root : fields[123],\n                    contract_address_salt : fields[124],\n                    portal_contract_address : fields[125],\n                },\n                chain_id: fields[126],\n                version: fields[127],\n            },\n            is_execution_request: fields[128] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/context"
      },
      "47": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let preimage = serialize(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/note/lifecycle"
      },
      "48": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(\n    fields: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    };\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/note/note_getter"
      },
      "50": {
        "source": "use dep::std::hash::{pedersen, pedersen_with_separator};\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen([storage_slot, note_hash])[0]\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)[0]\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)[0]\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/note/note_hash"
      },
      "54": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\npub fn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/note/utils"
      },
      "56": {
        "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/oracle/arguments"
      },
      "57": {
        "source": "use crate::constants_gen::CALL_PRIVATE_FUNCTION_RETURN_SIZE;\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: Field,\n    _function_selector: Field,\n    _args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: Field,\n    function_selector: Field,\n    args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {\n    call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n    )\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/oracle/call_private_function"
      },
      "66": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_created_note_oracle(storage_slot, preimage, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(\n    _nullifier: Field,\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S],\n)-> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, return_size, placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let preimage = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(preimage);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    };\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(\n    _inner_nullifier: Field,\n) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/oracle/notes"
      },
      "69": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    pub fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/private_call_stack_item"
      },
      "77": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{EMPTY_NULLIFIED_COMMITMENT, GENERATOR_INDEX__INITIALISATION_NULLIFIER};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note},\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::{\n    get_secret_key::get_secret_key,\n    notes::check_nullifier_exists,\n};\nuse dep::std::hash::pedersen_with_separator;\n\npub fn compute_singleton_initialization_nullifier(storage_slot: Field, owner: Option<Field>) -> Field {\n    if owner.is_some() {\n        let secret = get_secret_key(owner.unwrap_unchecked());\n        pedersen_with_separator(\n            [storage_slot, secret.low, secret.high],\n            GENERATOR_INDEX__INITIALISATION_NULLIFIER,\n        )[0]\n    } else {\n        pedersen_with_separator(\n            [storage_slot],\n            GENERATOR_INDEX__INITIALISATION_NULLIFIER,\n        )[0]\n    }\n}\n\n// docs:start:struct\nstruct Singleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<Field>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> Singleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Singleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<Field>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(self, note: &mut Note, owner: Option<Field>) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(self, new_note: &mut Note) {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note, self.note_interface);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, self.note_interface);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note(self) -> Note {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note, self.note_interface);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, self.note_interface);\n\n        note\n    }\n    // docs:end:get_note\n\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/state_vars/singleton"
      },
      "87": {
        "source": "pub fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/utils"
      },
      "90": {
        "source": "use dep::std::hash::pedersen_with_separator;\n\nuse dep::aztec::{\n  context::{PrivateContext, PublicContext, Context},\n  constants_gen::{EMPTY_NULLIFIED_COMMITMENT, GENERATOR_INDEX__SIGNATURE_PAYLOAD},\n  types::address::AztecAddress,\n  abi::hash_args,\n};\n\nglobal IS_VALID_SELECTOR = 0xe86ab4ff;\nglobal IS_VALID_PUBLIC_SELECTOR = 0xf3661153;\n\n// @todo #2676 Should use different generator than the payload to limit probability of collisions.\n\n// Assert that `whom` have authorized `message_hash` with a valid authentication witness\npub fn assert_valid_authwit(context: &mut PrivateContext, whom: AztecAddress, message_hash: Field) {\n  let result = context.call_private_function(whom.address, IS_VALID_SELECTOR, [message_hash])[0];\n  context.push_new_nullifier(message_hash, EMPTY_NULLIFIED_COMMITMENT);\n  assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n// Assert that `whom` have authorized the current call with a valid authentication witness\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, whom: AztecAddress) {\n  let args = [context.msg_sender(), context.this_address(), context.selector(), context.args_hash];\n  let message_hash = pedersen_with_separator(args, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n  assert_valid_authwit(context, whom, message_hash);\n}\n\n// Assert that `whom` have authorized `message_hash` in a public context\npub fn assert_valid_authwit_public(context: &mut PublicContext, whom: AztecAddress, message_hash: Field) {\n  let result = context.call_public_function(whom.address, IS_VALID_PUBLIC_SELECTOR, [message_hash])[0];\n  context.push_new_nullifier(message_hash, EMPTY_NULLIFIED_COMMITMENT);\n  assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n// Assert that `whom` have authorized the current call in a public context\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, whom: AztecAddress) {\n  let args = [context.msg_sender(), context.this_address(), context.selector(), context.args_hash];\n  let message_hash = pedersen_with_separator(args, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n  assert_valid_authwit_public(context, whom, message_hash);\n}\n\n// Compute the message hash to be used by an authentication witness \npub fn compute_authwit_message_hash<N>(caller: AztecAddress, target: AztecAddress, selector: Field, args: [Field; N]) -> Field {\n  let args_hash = hash_args(args);\n  pedersen_with_separator([caller.address, target.address, selector, args_hash], GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0]\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/authwit/src/auth"
      },
      "98": {
        "source": "use dep::aztec::note::note_interface::NoteInterface;\nuse dep::aztec::note::note_header::NoteHeader;\nuse dep::aztec::note::utils::compute_siloed_note_hash;\nuse dep::aztec::oracle::get_secret_key::get_secret_key;\n\nglobal ADDRESS_NOTE_LEN: Field = 1;\n\n// Stores an address\nstruct AddressNote {\n    address: Field,\n    header: NoteHeader,\n}\n\nimpl AddressNote {\n    pub fn new(address: Field) -> Self {\n        AddressNote {\n            address,\n            header: NoteHeader::empty(),\n        }\n    }\n\n    pub fn serialize(self) -> [Field; ADDRESS_NOTE_LEN] {\n        [self.address]\n    }\n\n    pub fn compute_nullifier(self) -> Field {\n        let siloed_note_hash = compute_siloed_note_hash(AddressNoteMethods, self);\n        dep::std::hash::pedersen([ siloed_note_hash ])[0]\n    }\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n}\n\nfn deserialize(preimage: [Field; ADDRESS_NOTE_LEN]) -> AddressNote {\n    AddressNote {\n        address: preimage[0],\n        header: NoteHeader::empty(),\n    }\n}\n\nfn serialize(note: AddressNote) -> [Field; ADDRESS_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: AddressNote) -> Field {\n    // TODO(#1205) Should use a non-zero generator index.\n    dep::std::hash::pedersen(note.serialize())[0]\n}\n\nfn compute_nullifier(note: AddressNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: AddressNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut AddressNote, header: NoteHeader) {\n    note.set_header(header);\n}\n\nglobal AddressNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n};\n",
        "path": "/Users/philogy/Documents/Aztec/noirder-book/contracts/trader/src/address_note"
      }
    }
  }
}