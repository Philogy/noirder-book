{
  "name": "Trader",
  "functions": [
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "token0",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "token1",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "trade_token0",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "token0_from",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "token1_from",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "amount_token0",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "amount_token1",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce_transfer_token0",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce_transfer_token1",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "debug": {
    "debugSymbols": [
      "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"
    ],
    "fileMap": {
      "1": {
        "source": "mod interfaces;\nmod address_note;\n\ncontract Trader {\n\n    use dep::std::option::Option;\n\n    use dep::aztec::{\n        state_vars::immutable_singleton::ImmutableSingleton,\n        context::{PrivateContext, PublicContext, Context},\n        types::address::AztecAddress\n    };\n\n    use dep::authwit::auth::assert_current_call_valid_authwit;\n\n    use crate::{\n        address_note::{AddressNote, ADDRESS_NOTE_LEN, AddressNoteMethods},\n        interfaces::Token\n    };\n\n    struct Storage {\n        token0: ImmutableSingleton<AddressNote, 1>,\n        token1: ImmutableSingleton<AddressNote, 1>\n    }\n\n    impl Storage {\n        fn init(context: Context) -> pub Self {\n            Storage {\n                token0: ImmutableSingleton::new(context, 1, AddressNoteMethods),\n                token1: ImmutableSingleton::new(context, 2, AddressNoteMethods)\n            }\n        }\n    }\n\n\n    #[aztec(private)]\n    fn constructor(token0: Field, token1: Field) {\n        storage.token0.initialize(&mut AddressNote::new(token0), Option::none());\n        storage.token1.initialize(&mut AddressNote::new(token1), Option::none());\n    }\n\n    #[aztec(private)]\n    fn trade_token0(\n        token0_from: AztecAddress,\n        token1_from: AztecAddress,\n        amount_token0: Field,\n        amount_token1: Field,\n        nonce: Field,\n        nonce_transfer_token0: Field,\n        nonce_transfer_token1: Field\n    ) {\n        assert_current_call_valid_authwit(&mut context, token0_from);\n        assert (token1_from.address == context.msg_sender());\n\n        Token::at(storage.token0.get_note().address).transfer(\n            &mut context,\n            token0_from.address,\n            token1_from.address,\n            amount_token0,\n            nonce_transfer_token0\n        );\n        Token::at(storage.token1.get_note().address).transfer(\n            &mut context,\n            token1_from.address,\n            token0_from.address,\n            amount_token1,\n            nonce_transfer_token1\n        );\n    }\n}\n",
        "path": "/Users/philogy/Documents/Aztec/noirder-book/contracts/trader/src/main"
      },
      "6": {
        "source": "mod poseidon;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input : [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input : [u8; N]) -> [u8; 32] {}\n\npub fn pedersen<N>(input : [Field; N]) -> [Field; 2] {\n    pedersen_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\npub fn pedersen_with_separator<N>(_input : [Field; N], _separator : u32) -> [Field; 2] {}\n\n#[foreign(hash_to_field_128_security)]\npub fn hash_to_field<N>(_input : [Field; N]) -> Field {}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input : [u8; N], _message_size: u32) -> [u8; 32] {}\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\nfn mimc<N>(x: Field, k: Field, constants: [Field; N], exp : Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1 .. constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    };\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS = 91;\n\n//mimc implementation with hardcoded parameters for BN254 curve.\npub fn mimc_bn254<N>(array: [Field; N]) -> Field {\n    //mimc parameters\n    let exponent = 7;\n    //generated from seed \"mimc\" using keccak256 \n    let constants: [Field; MIMC_BN254_ROUNDS] = [\n        0, \n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533,\n    ];\n\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, constants, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n",
        "path": "std/hash"
      },
      "34": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option"
      },
      "37": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\n// docs:start:historic-block-data\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:historic-block-data\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/abi"
      },
      "40": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, self.this_address(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 49),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 65),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 81),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 97),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 101),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 105),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 107),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 109),\n                encrypted_log_preimages_length: fields[111],\n                unencrypted_log_preimages_length: fields[112],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[113],\n                    nullifier_tree_root : fields[114],\n                    contract_tree_root : fields[115],\n                    l1_to_l2_messages_tree_root : fields[116],\n                    blocks_tree_root : fields[117],\n                    public_data_tree_root: fields[118],\n                    global_variables_hash: fields[119],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[120], fields[121]),\n                    constructor_vk_hash : fields[122],\n                    function_tree_root : fields[123],\n                    contract_address_salt : fields[124],\n                    portal_contract_address : fields[125],\n                },\n                chain_id: fields[126],\n                version: fields[127],\n            },\n            is_execution_request: fields[128] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/context"
      },
      "47": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let preimage = serialize(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/note/lifecycle"
      },
      "48": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(\n    fields: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    };\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/note/note_getter"
      },
      "50": {
        "source": "use dep::std::hash::{pedersen, pedersen_with_separator};\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen([storage_slot, note_hash])[0]\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)[0]\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)[0]\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/note/note_hash"
      },
      "54": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\npub fn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/note/utils"
      },
      "56": {
        "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/oracle/arguments"
      },
      "57": {
        "source": "use crate::constants_gen::CALL_PRIVATE_FUNCTION_RETURN_SIZE;\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: Field,\n    _function_selector: Field,\n    _args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: Field,\n    function_selector: Field,\n    args_hash: Field\n) -> [Field; CALL_PRIVATE_FUNCTION_RETURN_SIZE] {\n    call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n    )\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/oracle/call_private_function"
      },
      "66": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _preimage: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    preimage: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_created_note_oracle(storage_slot, preimage, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(\n    _nullifier: Field,\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S],\n)-> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, return_size, placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let preimage = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(preimage);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    };\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(\n    _inner_nullifier: Field,\n) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/oracle/notes"
      },
      "69": {
        "source": "use crate::abi::FunctionData;\nuse crate::abi::PrivateCircuitPublicInputs;\nuse crate::constants_gen::GENERATOR_INDEX__CALL_STACK_ITEM;\n\nstruct PrivateCallStackItem {\n    contract_address: Field,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n    is_execution_request: bool,\n}\n\nimpl PrivateCallStackItem {\n    pub fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.contract_address,\n            self.function_data.hash(),\n            self.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)[0]\n    }\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/private_call_stack_item"
      },
      "77": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{EMPTY_NULLIFIED_COMMITMENT, GENERATOR_INDEX__INITIALISATION_NULLIFIER};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note},\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::{\n    get_secret_key::get_secret_key,\n    notes::check_nullifier_exists,\n};\nuse dep::std::hash::pedersen_with_separator;\n\npub fn compute_singleton_initialization_nullifier(storage_slot: Field, owner: Option<Field>) -> Field {\n    if owner.is_some() {\n        let secret = get_secret_key(owner.unwrap_unchecked());\n        pedersen_with_separator(\n            [storage_slot, secret.low, secret.high],\n            GENERATOR_INDEX__INITIALISATION_NULLIFIER,\n        )[0]\n    } else {\n        pedersen_with_separator(\n            [storage_slot],\n            GENERATOR_INDEX__INITIALISATION_NULLIFIER,\n        )[0]\n    }\n}\n\n// docs:start:struct\nstruct Singleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<Field>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> Singleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Singleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<Field>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(self, note: &mut Note, owner: Option<Field>) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(self, new_note: &mut Note) {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note, self.note_interface);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, self.note_interface);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note(self) -> Note {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note, self.note_interface);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, self.note_interface);\n\n        note\n    }\n    // docs:end:get_note\n\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n}\n",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/state_vars/singleton"
      },
      "87": {
        "source": "pub fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/aztec/src/utils"
      },
      "90": {
        "source": "use dep::std::hash::pedersen_with_separator;\n\nuse dep::aztec::{\n  context::{PrivateContext, PublicContext, Context},\n  constants_gen::{EMPTY_NULLIFIED_COMMITMENT, GENERATOR_INDEX__SIGNATURE_PAYLOAD},\n  types::address::AztecAddress,\n  abi::hash_args,\n};\n\nglobal IS_VALID_SELECTOR = 0xe86ab4ff;\nglobal IS_VALID_PUBLIC_SELECTOR = 0xf3661153;\n\n// @todo #2676 Should use different generator than the payload to limit probability of collisions.\n\n// Assert that `whom` have authorized `message_hash` with a valid authentication witness\npub fn assert_valid_authwit(context: &mut PrivateContext, whom: AztecAddress, message_hash: Field) {\n  let result = context.call_private_function(whom.address, IS_VALID_SELECTOR, [message_hash])[0];\n  context.push_new_nullifier(message_hash, EMPTY_NULLIFIED_COMMITMENT);\n  assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n// Assert that `whom` have authorized the current call with a valid authentication witness\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, whom: AztecAddress) {\n  let args = [context.msg_sender(), context.this_address(), context.selector(), context.args_hash];\n  let message_hash = pedersen_with_separator(args, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n  assert_valid_authwit(context, whom, message_hash);\n}\n\n// Assert that `whom` have authorized `message_hash` in a public context\npub fn assert_valid_authwit_public(context: &mut PublicContext, whom: AztecAddress, message_hash: Field) {\n  let result = context.call_public_function(whom.address, IS_VALID_PUBLIC_SELECTOR, [message_hash])[0];\n  context.push_new_nullifier(message_hash, EMPTY_NULLIFIED_COMMITMENT);\n  assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n// Assert that `whom` have authorized the current call in a public context\npub fn assert_current_call_valid_authwit_public(context: &mut PublicContext, whom: AztecAddress) {\n  let args = [context.msg_sender(), context.this_address(), context.selector(), context.args_hash];\n  let message_hash = pedersen_with_separator(args, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n  assert_valid_authwit_public(context, whom, message_hash);\n}\n\n// Compute the message hash to be used by an authentication witness \npub fn compute_authwit_message_hash<N>(caller: AztecAddress, target: AztecAddress, selector: Field, args: [Field; N]) -> Field {\n  let args_hash = hash_args(args);\n  pedersen_with_separator([caller.address, target.address, selector, args_hash], GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0]\n}",
        "path": "/Users/philogy/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.8.8/yarn-project/aztec-nr/authwit/src/auth"
      },
      "98": {
        "source": "use dep::aztec::note::note_interface::NoteInterface;\nuse dep::aztec::note::note_header::NoteHeader;\nuse dep::aztec::note::utils::compute_siloed_note_hash;\nuse dep::aztec::oracle::get_secret_key::get_secret_key;\n\nglobal ADDRESS_NOTE_LEN: Field = 1;\n\n// Stores an address\nstruct AddressNote {\n    address: Field,\n    header: NoteHeader,\n}\n\nimpl AddressNote {\n    pub fn new(address: Field) -> Self {\n        AddressNote {\n            address,\n            header: NoteHeader::empty(),\n        }\n    }\n\n    pub fn serialize(self) -> [Field; ADDRESS_NOTE_LEN] {\n        [self.address]\n    }\n\n    pub fn compute_nullifier(self) -> Field {\n        let siloed_note_hash = compute_siloed_note_hash(AddressNoteMethods, self);\n        dep::std::hash::pedersen([ siloed_note_hash ])[0]\n    }\n\n    pub fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n}\n\nfn deserialize(preimage: [Field; ADDRESS_NOTE_LEN]) -> AddressNote {\n    AddressNote {\n        address: preimage[0],\n        header: NoteHeader::empty(),\n    }\n}\n\nfn serialize(note: AddressNote) -> [Field; ADDRESS_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: AddressNote) -> Field {\n    // TODO(#1205) Should use a non-zero generator index.\n    dep::std::hash::pedersen(note.serialize())[0]\n}\n\nfn compute_nullifier(note: AddressNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: AddressNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut AddressNote, header: NoteHeader) {\n    note.set_header(header);\n}\n\nglobal AddressNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n};\n",
        "path": "/Users/philogy/Documents/Aztec/noirder-book/contracts/trader/src/address_note"
      }
    }
  }
}